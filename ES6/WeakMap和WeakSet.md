# Map/WeakMap
### Map
1. Key 可为任意值：在 Map 中，键（key）可以是任意值，包括基本数据类型和对象引用。
2. 内存管理：Map 不会因为持有键的引用而阻止键被垃圾回收。即使 Map 中的键被移除，相关的值也不会被自动释放。
3. 迭代支持：Map 提供了丰富的迭代方法，包括 forEach、entries、keys 和 values。
### WeakMap:
1. Key 必须为对象：在 WeakMap 中，键必须是对象。基本数据类型不能作为键。
2. 内存管理：WeakMap 的特点是它的键对值的引用是弱引用。这意味着如果键不再被引用，垃圾回收机制可以回收键，同时对应的值也会被释放。
3. 迭代不支持：WeakMap 不提供像 Map 那样的迭代方法，因为键的引用是弱引用，无法保证在迭代的过程中键是否仍然存在。
4. 没有 size 属性：WeakMap 没有 size 属性，因此不能获取当前键值对的数量。

#### 选择使用场景：
使用 Map 当你需要保存键值对，并且键可以是任意值，或者你需要对集合进行迭代  
使用 WeakMap 当你想要确保在没有其他引用时自动释放键对应的值，或者需要私有性质的存储（即键无法被外部访问或枚举）  
总体而言，Map 更通用，而 WeakMap 更适用于特定的场景，如私有性质的存储或需要自动垃圾回收的场景  



# Set与WeakSet

### Set:
1. Key 可为任意值：在 Set 中，元素可以是任意值，包括基本数据类型和对象引用。
2. 内存管理：Set 不会因为持有元素的引用而阻止元素被垃圾回收。
3. 迭代支持：Set 提供了丰富的迭代方法，包括 forEach、entries、keys 和 values。
4. 没有私有性：Set 中的元素是公开的，可以通过迭代方法或 has 方法检查元素是否存在。

### WeakSet:
1. 元素必须为对象：在 WeakSet 中，元素必须是对象。基本数据类型不能作为元素。
2. 内存管理：WeakSet 的特点是它的元素对值的引用是弱引用。这意味着如果元素不再被引用，垃圾回收机制可以回收元素。
3. 迭代不支持：WeakSet 不提供像 Set 那样的迭代方法，因为元素的引用是弱引用，无法保证在迭代的过程中元素是否仍然存在。
4. 没有 size 属性：WeakSet 没有 size 属性，因此不能获取当前元素的数量。
5. 没有清空方法：WeakSet 没有像 Set 的 clear 方法，因为元素是弱引用，不能保证在清空后引用是否被其他地方持有。

#### 使用场景
使用 Set 当你需要保存任意值的集合，并且需要对集合进行迭代。
使用 WeakSet 当你想要确保在没有其他引用时自动释放元素，或者需要私有性质的存储。
