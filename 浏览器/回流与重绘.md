# 回流与重绘
在HTML中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘：
**回流**：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置  
**重绘**：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制  

**浏览器解析渲染机制**如下所示：
![浏览器渲染](../img/browser渲染.md.png)
1. 获取并解析HTML，生成DOM树，解析CSS，生成CSSOM树
2. 将DOM树和CSSOM树结合，生成渲染树(Render Tree)
3. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
4. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. Display:将像素发送给GPU，展示在页面上

在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变

当我们对 DOM 的修改引发了 **DOM几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）**时，浏览器需要**重新计算元素的几何属性**，然后再将计算的结果绘制出来

当我们对 DOM的**修改导致了样式的变化（color或background-color）**，却并未影响其几何属性时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了**重绘**

# 如何触发
## 回流触发时机
回流这一阶段主要是**计算节点的位置和几何信息**，那么当**页面布局和几何信息发生变化的时候**，就需要回流  
如下： 
1. 添加或删除可见的DOM元素
2. 元素的位置发生变化
3. 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
4. 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代
5. 页面一开始渲染的时候（这避免不了）
6. 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
7. 获取一些特定属性的值：  
offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight  
这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流

## 重绘触发时机
可以把页面理解为一个黑板，黑板上有一朵画好的小花。现在我们要把这朵从左边移到了右边，那我们要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜色（重绘）

触发回流一定会触发重绘，其他引起重绘行为：
1. 颜色的修改
2. 文本方向的修改
3. 阴影的修改
4. 浏览器优化机制
由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列   
当你获取布局信息的操作的时候，会强制队列刷新，因此浏览器不得不清空队列，触发回流重绘来返回正确的值  

# 如何减少重排与重绘？
**减少重排和重绘的目标是尽量减少对布局信息的频繁读取和修改，使得浏览器可以更高效地渲染页面。**
1. 使用 Class 进行样式修改： 避免直接操作元素的 style 属性，而是通过修改元素的 class 来改变样式。这样可以减少对元素的直接样式改变，从而减少重排和重绘。

```css
// 避免
element.style.width = '100px';
element.style.height = '50px';
// 推荐
element.classList.add('new-style');
```
2. 使用文档碎片（DocumentFragment）： 当需要进行多次 DOM 操作时，可以使用文档碎片进行离线操作，然后一次性将文档碎片添加到文档中。这可以减少多次插入的重排。

```javascript
var fragment = document.createDocumentFragment();

for (var i = 0; i < 100; i++) {
  var div = document.createElement('div');
  fragment.appendChild(div);
}

document.body.appendChild(fragment);
```
3. 使用 CSS 动画和 transform： CSS 动画和 transform 属性通常不会引起重排，而是使用 GPU 加速，减少对 CPU 的负担。

4. 避免频繁读取布局信息： 当需要获取元素的位置、尺寸等信息时，尽量将这些读取的操作集中在一起，避免多次读取，以减少重排。

5. 避免在循环中直接操作样式： 在循环中直接操作样式可能会导致多次重排。可以在循环结束前集中进行样式修改，或者使用批量修改的方式。

6. 使用 translate 替代 top/left： 在使用动画时，尽量使用 transform: translate(x, y) 替代直接修改 top 和 left。transform 不会引起重排，而直接修改 top 和 left 会。
```css
// 避免
element.style.top = '10px';
element.style.left = '20px';
// 推荐
element.style.transform = 'translate(10px, 20px)';
```
