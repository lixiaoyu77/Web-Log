## 什么是防抖节流？具体的衡量指标

**它们的主要目的是减少不必要的函数调用次数，从而节省资源并改善页面性能**

# 防抖（Debouncing）
防抖的基本思想是延迟函数的执行，直到某个连续动作结束。当事件触发后，如果在指定的时间间隔内再次触发了相同的事件，旧的事件会被取消并重新计时，直到没有新事件触发，最后一次事件才会被执行。

# 节流（Throttling）
节流是控制函数执行频率的一种技术，确保函数在一定时间间隔内执行的频率不会超过设定的阈值。它会固定执行函数的时间间隔，无论事件触发的频率如何，都只会在固定的时间间隔内执行一次。


## 如何衡量它们的性能提升？
1. 函数调用次数
通过防抖和节流技术，可以明显减少函数的调用次数。使用开发者工具中的性能分析器或者在代码中加入计数器，统计函数被调用的次数，对比优化前后的差异。
2. 网络请求次数
在涉及网络请求的场景中，如搜索框输入实时查询、滚动加载数据等，防抖和节流能减少不必要的网络请求次数，从而减轻服务器负载，节省带宽。
3. 用户体验
减少不必要的事件触发，改善用户体验。在交互频繁的地方，如输入框搜索、页面滚动等，使用防抖和节流技术可以让页面更加流畅，减少卡顿感，提升用户满意度。
4. 性能优化工具的反馈
一些性能优化工具可以提供对防抖和节流优化效果的评估。例如，使用 Lighthouse 或者 Chrome 开发者工具进行性能评估，观察页面加载和交互性能是否有所改善。


一、
本质上是优化高频率执行代码的一种手段

如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能

为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 防抖（debounce） 和 节流（throttle） 的方式来减少调用频率

#定义

#代码实现
#节流
完成节流可以使用时间戳与定时器的写法

使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行

function throttled1(fn, delay = 500) {
    let oldtime = Date.now()
    return function (...args) {
        let newtime = Date.now()
        if (newtime - oldtime >= delay) {
            fn.apply(null, args)
            oldtime = Date.now()
        }
    }
}

使用定时器写法，delay毫秒后第一次执行，第二次事件停止触发后依然会再一次执行

function throttled2(fn, delay = 500) {
    let timer = null
    return function (...args) {
        if (!timer) {
            timer = setTimeout(() => {
                fn.apply(this, args)
                timer = null
            }, delay);
        }
    }
}

#防抖
简单版本的实现

function debounce(func, wait) {
    let timeout;

    return function () {
        let context = this; // 保存this指向
        let args = arguments; // 拿到event对象

        clearTimeout(timeout)
        timeout = setTimeout(function(){
            func.apply(context, args)
        }, wait);
    }
}
防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：

function debounce(func, wait, immediate) {

    let timeout;

    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout); // timeout 不为null
        if (immediate) {
            let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发
            timeout = setTimeout(function () {
                timeout = null;
            }, wait)
            if (callNow) {
                func.apply(context, args)
            }
        }
        else {
            timeout = setTimeout(function () {
                func.apply(context, args)
            }, wait);
        }
    }
}
#二、区别
相同点：

都可以通过使用 setTimeout 实现
目的都是，降低回调执行频率。节省计算资源
不同点：

函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能
函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次
例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次



#  应用场景
**防抖** 在连续的事件，只需触发一次回调的场景有：
1. 搜索框搜索输入。只需用户最后一次输入完，再发送请求
2. 手机号、邮箱验证输入检测
3. 窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染
4. 页面元素绑定滚动事件，延迟处理滚动操作，防止过于频繁地触发

**节流** 在间隔一段时间执行一次回调的场景有：
1. 页面元素的滚动加载更多内容，限制滚动事件触发的频率，确保在一段时间内只加载一次数据
2. 用户频繁点击按钮，设置间隔时间，防止用户连续点击多次造成意外操作