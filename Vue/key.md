## 你知道vue中key的原理吗？说说你对它的理解.

# key是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点


## 当 Vue 用 v-for 指令渲染一组数据时，它会尽可能高效地复用已经存在的 DOM 元素，基于以下几点：

# 区分不同项
key 的主要作用是给每个节点设置一个唯一的标识，以便 Vue 能够准确地识别每个节点。这有助于 Vue 正确追踪每个节点的状态变化。

# 优化节点的重新排序和复用
当数据发生变化时，Vue 会尽可能地复用已存在的 DOM 元素，并在新旧数据的对比中，通过 key 识别哪些元素是已经存在的、需要更新的，哪些是新添加或被移除的。没有设置 key 时，Vue 可能会出现一些意外的渲染问题，比如节点的重新排序可能会导致不必要的 DOM 操作或状态丢失。

# 确保组件状态的正确性
在动态组件中，如果不使用 key，在组件切换时，旧组件的状态可能会被新组件继承，这可能导致意料之外的行为。通过设置 key，可以确保 Vue 将旧组件完全销毁并重新创建新组件，从而避免状态混乱或意外行为。

### key能够大大减少对页面的DOM操作，提高了diff效率
### 设置key值一定能提高diff效率吗？
# 其实不然，文档中也明确表示
# 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素
## 创建一个实例，2秒后往items数组插入数据
<body>
  <div id="demo">
    <p v-for="item in items" :key="item">{{item}}</p>
  </div>
  <script src="../../dist/vue.js"></script>
  <script>
    // 创建实例
    const app = new Vue({
      el: '#demo',
      data: { items: ['a', 'b', 'c', 'd', 'e'] },
      mounted () {
        setTimeout(() => { 
          this.items.splice(2, 0, 'f')  // 
       }, 2000);
     },
   });
  </script>
</body>

# 在不使用key的情况，vue会进行这样的操作：
比较A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作
比较B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作
比较C，F，相同类型的节点，进行patch，数据不同，发生dom操作
比较D，C，相同类型的节点，进行patch，数据不同，发生dom操作
比较E，D，相同类型的节点，进行patch，数据不同，发生dom操作
循环结束，将E插入到DOM中
一共发生了3次更新，1次插入操作

# 在使用key的情况：vue会进行这样的操作：
比较A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作
比较B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作
比较C，F，不相同类型的节点
比较E、E，相同类型的节点，进行patch，但数据相同，不发生dom操作
比较D、D，相同类型的节点，进行patch，但数据相同，不发生dom操作
比较C、C，相同类型的节点，进行patch，但数据相同，不发生dom操作
循环结束，将F插入到C之前
一共发生了0次更新，1次插入操作