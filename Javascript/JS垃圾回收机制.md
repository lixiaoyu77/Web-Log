## 垃圾回收机制（GC：Garbage Collecation）

Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，垃圾回收器会每隔一段时间找出那些不再使用的内存，然后为其释放内存  
**原理**：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存

#### 两种实现方式：

##### 标记清除

JavaScript 最常用的垃圾收回机制

当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“  
垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉  
在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了  
随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存

```js
var m = 0,
  n = 19 // 把 m,n,add() 标记为进入环境。
add(m, n) // 把 a, b, c 标记为进入环境。
console.log(n) // a,b,c 标记为离开环境，等待垃圾回收。
function add(a, b) {
  a++
  var c = a + b
  return c
}
```

##### 引用计数

引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间。

语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是 0，就表示这个值不再用到了，因此可以将这块内存释放

如果一个值不再需要了，引用数却不为 0，垃圾回收机制无法释放这块内存，从而导致内存泄漏

```js
const arr = [1, 2, 3, 4]
console.log('hello world')
```

上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量 arr 是仅有的对这个值的引用，因此引用次数为 1。尽管后面的代码没有用到 arr，它还是会持续占用内存  
如果需要这块内存被垃圾回收机制释放，只需要设置如下：

```js
arr = null
```

通过设置 arr 为 null，就解除了对数组[1,2,3,4]的引用，引用次数变为 0，就被垃圾回收了

## 小结

有了垃圾回收机制，不代表不用关注内存泄露。那些很占空间的值，一旦不再用到，需要检查是否还存在对它们的引用。如果是的话，就必须手动解除引用
