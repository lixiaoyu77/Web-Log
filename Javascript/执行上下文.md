# 执行上下文

只要有 Javascript 代码运行，那么它就一定是运行在执行上下文中

**三种执行上下文**：

1. 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象
2. 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文
3. Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用(它的功能是把对应的字符串解析成 JS 代码并运行；应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）。)

# 执行上下文的生命周期

**三个阶段：** 创建阶段 → 执行阶段 → 回收阶段

## 创建阶段

创建阶段即当函数被调用，但未执行任何其内部代码之前

创建阶段做了三件事：

1. 确定 this 的值，也被称为 This Binding
   确定 this 的值我们前面讲到，this 的值是在执行的时候才能确认，定义的时候不能确认
2. LexicalEnvironment **词法环境** 组件被创建
3. 全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null，有一个全局对象，this 的值指向这个全局对象
4. 函数环境：用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境
5. VariableEnvironmen **变量环境** 组件被创建

**在 ES6 中，词法环境和变量环境的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定**

## 执行阶段

执行变量赋值、代码执行  
如果 Javascript 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 undefined 值

## 回收阶段

执行上下文出栈等待虚拟机回收执行上下文

# 执行栈

执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文

当 Javascript 引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中  
每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中  
引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文

```javascript
let a = 'Hello World!'
function first() {
  console.log('Inside first function')
  second()
  console.log('Again inside first function')
}
function second() {
  console.log('Inside second function')
}
first()
console.log('Inside Global Execution Context')
```

**流程：**

1. 创建全局上下文请压入执行栈
2. first 函数被调用，创建函数执行上下文并压入栈
3. 执行 first 函数过程遇到 second 函数，再创建一个函数执行上下文并压入栈
4. second 函数执行完毕，对应的函数执行上下文被推出执行栈，执行下一个执行上下文 first 函数
5. first 函数执行完毕，对应的函数执行上下文也被推出栈中，然后执行全局上下文
6. 所有代码执行完毕，全局上下文也会被推出栈中，程序结束
