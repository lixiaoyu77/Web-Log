# 精度丢失
值计算、保留指定小数位、接口返回数值过大...这些操作都有可能导致原本正常的数值在 JavaScript 中确表现得异常（精度丢失）

# 精度丢失场景
浮点数的计算
1、加法和减法
```javascript
0.1 + 0.2 // 结果为 0.30000000000000004
0.3 - 0.1 // 结果为 0.19999999999999996
// 这是因为浮点数的二进制表示无法准确表示某些十进制小数，导致计算结果存在微小的误差。
```
2、乘法和除法
```javascript
0.1 * 0.2 // 结果为 0.020000000000000004
0.3 / 0.1 // 结果为 2.9999999999999996
// 在进行乘法和除法时，浮点数计算结果的精度问题更为突出，可能会产生更大的误差。
```
3、比较运算 **一个经典的面试题**
```javascript
0.1 + 0.2 === 0.3 // 结果为 false
// 直接比较浮点数可能会导致不准确的结果，因为计算结果的微小误差可能使它们不完全相等。
```



# 问题分析
计算机存储双精度浮点数需要先把十进制数转换为二进制的科学记数法的形式，然后计算机以自己的规则{符号位+(指数位+指数偏移量的二进制)+小数部分}存储二进制的科学记数法  
因为存储时有位数限制（64位），并且某些十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0舍1入)，当再转换为十进制时就造成了计算误差  

```javascript
0.1 + 0.2 === 0.3 // false
// 0.1 和 0.2 都转化成二进制后再进行运算
0.00011001100110011001100110011001100110011001100110011010 +
0.0011001100110011001100110011001100110011001100110011010 =
0.0100110011001100110011001100110011001100110011001100111
// 转成十进制正好是 0.30000000000000004
所以输出false
```

# 精度丢失的原因
计算机内部实际上只能 存储/识别 二进制，因此 文档、图片、数字 等都会被转换为 二进制，而对于数字而言，虽然我们看到的是 十进制 的表示结果，但实际上会底层会进行 十进制 和 二进制 的相互转换，而这个转换过程就有可能会出现 精度丢失，因为十进制转二进制后可能产生 无限循环 部分，而 实际存储空间是有限的。

由于计算机内部使用二进制浮点数表示法，而不是十进制。这种二进制表示法在某些情况下无法准确地表示某些十进制小数，从而导致精度丢失，如：

1. 无法精确表示的十进制小数：
        某些十进制小数无法准确地表示为有限长度的二进制小数。例如，0.1 和 0.2 这样的十进制小数在二进制表示中是无限循环的小数，因此在计算机内部以有限的位数进行表示时，会存在舍入误差，导致精度丢失。
2. 舍入误差：
        由于浮点数的位数是有限的，对于无法精确表示的十进制小数，计算机进行舍入来逼近其值。这种舍入操作会引入误差，并导致计算结果与预期值之间的差异。
        Number.prototype.toFixed 的舍入：关于这个方法的舍入方式，目前最多的说法就是 银行家算法 ，的确在大多情况下确实能够符合 银行家算法 的规则，但是部分情况就并不符合其规则，因此严格意义上来讲 Number.prototype.toFixed 并不算是使用了 银行家算法。（银行家舍入：所谓银行家舍入法，其实质是一种四舍六入五取偶（又称四舍六入五留双）法。 简单来说就是：四舍六入五考虑，五后非零就进一，五后为零看奇偶，五前为偶应舍去，五前为奇要进一。具体解释见下文） 
3. 算术运算的累积误差：
        在进行一系列浮点数算术运算时，舍入误差可能会累积并导致精度丢失。每一次运算都会引入一些误差，这些误差在多次运算中逐渐累积，导致最终结果的精度降低。
4. 比较运算的不精确性：
        由于浮点数的表示精度有限，直接比较浮点数可能会导致不准确的结果。微小的舍入误差可能使得两个看似相等的浮点数在比较时被认为是不等的。
5. 数值范围的限制：
        超过最值（最大、最小值） 指的是超过了 Number.MIN_SAFE_INTEGER（- 9007199254740991），**即 +（2^53 – 1） 或 Number.MAX_SAFE_INTEGER（+ 9007199254740991），即 -（2^53 – 1） 范围的值**

# 解决方案
1. 精确加法
以加法为例：  
```javascript
/**
 * 精确加法
 */
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}
```

2. 超过最值时，接口以 **字符串** 的形式返回对应的值
前面提到的 后端返回 或 前端计算 产生的超过 安全范围的值，我们可以使用 BigInt 来处理，这是新增的原始值类型，它提供了一种方法来表示 大于 2^53 - 1 的整数。  
这里的 **BigInt** 不能用来处理后端返回超过安全范围内的值（如 id），因为当我们需要再将这些值转为 BigInt 之前就已经发生了精度丢失，所以在进行转换是无意义的。此时**最好的方式**就是让后端处理数据，使接口以 字符串 的形式返回对应的值。

3. 使用专门的库或工具
在处理需要高精度计算的场景中，可以使用一些专门的库或工具，以避免精度丢失的问题。
math.js、big.js、bignumber.js、decimal.js