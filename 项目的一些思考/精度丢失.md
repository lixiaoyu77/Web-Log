# 精度丢失
值计算、保留指定小数位、接口返回数值过大...这些操作都有可能导致原本正常的数值在 JavaScript 中确表现得异常（精度丢失）

# 精度丢失场景
浮点数的计算
1、加法和减法
```javascript
0.1 + 0.2 // 结果为 0.30000000000000004
0.3 - 0.1 // 结果为 0.19999999999999996
// 这是因为浮点数的二进制表示无法准确表示某些十进制小数，导致计算结果存在微小的误差。
```
2、乘法和除法
```javascript
0.1 * 0.2 // 结果为 0.020000000000000004
0.3 / 0.1 // 结果为 2.9999999999999996
// 在进行乘法和除法时，浮点数计算结果的精度问题更为突出，可能会产生更大的误差。
```
3、比较运算
```javascript
0.1 + 0.2 === 0.3 // 结果为 false
// 直接比较浮点数可能会导致不准确的结果，因为计算结果的微小误差可能使它们不完全相等。
```
## 超过最值
    所谓 超过最值（最大、最小值） 指的是超过了 Number.MIN_SAFE_INTEGER（- 9007199254740991），即 +（2^53 – 1） 或 Number.MAX_SAFE_INTEGER（+ 9007199254740991），即 -（2^53 – 1） 范围的值，项目中最常见的就是如下几种情况：1
1. 后端返回的数值超过最值
    例一，后端返回的列表数据，通常都会有相应的 ID 来标识唯一性，但后端生成这个 ID 时是 Long 类型，那么该值很可能就会超过 JavaScript 中能表示的最大正整数，此时就导致精度丢失，即前端实际获取到的 ID 值和后端返回的将不一致。
    例二，后端可能需要将一些值通过计算之后，把对应的结果值返回给前端，此时若该值超过了 最值，那么也会产生精度丢失。
2. 前端进行数值计算时，计算结果超过最值
3. 保留指定小数位
    除了上述对涉及浮点数计算、超过最值的场景之外，我们通常还会对数值进行保留指定小数位的处理，而部分开发者可能会直接使用 Number.prototype.toFixed 来实现，但这个方法却并不能保证我们期望的效果，例如保留小数位时需要进行 四舍五入 时就会有问题，如下：
```javascript
console.log(1.595.toFixed(2)) // 1.59 ——> 期望为：1.60
console.log(1.585.toFixed(2)) // 1.58 ——> 期望为：1.59
console.log(1.575.toFixed(2)) // 1.57 ——> 期望为：1.58
console.log(1.565.toFixed(2)) // 1.56 ——> 期望为：1.57
console.log(1.555.toFixed(2)) // 1.55 ——> 期望为：1.56
console.log(1.545.toFixed(2)) // 1.54 ——> 期望为：1.55
console.log(1.535.toFixed(2)) // 1.53 ——> 期望为：1.54
console.log(1.525.toFixed(2)) // 1.52 ——> 期望为：1.53
console.log(1.515.toFixed(2)) // 1.51 ——> 期望为：1.52
```

# 精度丢失的原因
计算机内部实际上只能 存储/识别 二进制，因此 文档、图片、数字 等都会被转换为 二进制，而对于数字而言，虽然我们看到的是 十进制 的表示结果，但实际上会底层会进行 十进制 和 二进制 的相互转换，而这个转换过程就有可能会出现 精度丢失，因为十进制转二进制后可能产生 无限循环 部分，而 实际存储空间是有限的。

由于计算机内部使用二进制浮点数表示法，而不是十进制。这种二进制表示法在某些情况下无法准确地表示某些十进制小数，从而导致精度丢失，如：

1. 无法精确表示的十进制小数：

        某些十进制小数无法准确地表示为有限长度的二进制小数。例如，0.1 和 0.2 这样的十进制小数在二进制表示中是无限循环的小数，因此在计算机内部以有限的位数进行表示时，会存在舍入误差，导致精度丢失。


2. 舍入误差：
        由于浮点数的位数是有限的，对于无法精确表示的十进制小数，计算机进行舍入来逼近其值。这种舍入操作会引入误差，并导致计算结果与预期值之间的差异。

        Number.prototype.toFixed 的舍入：关于这个方法的舍入方式，目前最多的说法就是 银行家算法 ，的确在大多情况下确实能够符合 银行家算法 的规则，但是部分情况就并不符合其规则，因此严格意义上来讲 Number.prototype.toFixed 并不算是使用了 银行家算法。（银行家舍入：所谓银行家舍入法，其实质是一种四舍六入五取偶（又称四舍六入五留双）法。 简单来说就是：四舍六入五考虑，五后非零就进一，五后为零看奇偶，五前为偶应舍去，五前为奇要进一。具体解释见下文） 


3. 算术运算的累积误差：
        在进行一系列浮点数算术运算时，舍入误差可能会累积并导致精度丢失。每一次运算都会引入一些误差，这些误差在多次运算中逐渐累积，导致最终结果的精度降低。

4. 比较运算的不精确性：
        由于浮点数的表示精度有限，直接比较浮点数可能会导致不准确的结果。微小的舍入误差可能使得两个看似相等的浮点数在比较时被认为是不等的。

5. 数值范围的限制：
        浮点数的表示范围是有限的，超出范围的数值可能会导致溢出或下溢，进而影响计算结果的精度。

# 解决
1. 使用整数进行计算（先放大再缩小）
既然我们遇到小数计算时才会出现误差，那么我们完全可以先把小数变整数计算之后再变成小数，这样就不会存在精度的问题。尽可能地将浮点数转换为整数进行计算。
例如，通过将小数位数乘以一个固定的倍数，将浮点数转换为整数，进行计算后再将结果转换回浮点数。这可以减少浮点数计算中的精度问题。

以 0.1 + 0.2 = 0.30000000000000004 举个例子，如下：
原式：0.1 + 0.2 = x
扩大 100 倍：0.1 * 100 + 0.2 * 100 = 100 * x
变式：100 * x = 3
结果：x = 0.3
```javascript
let num1 = 0.1,num2 = 0.2;
console.log((num1*100+num2*100)/100); //0.3 此方法局限就在于需要知道计算数字是几位小数。
```
2. 使用专门的库或工具
在处理需要高精度计算的场景中，可以使用一些专门的库或工具。例如，JavaScript 中的 Decimal.js、Big.js 或 BigNumber.js 等库提供了高精度的数学计算功能，可以避免精度丢失的问题。

需要的自行查阅：
math.js
big.js
bignumber.js
decimal.js

3. 超过最值时，接口以 字符串 的形式返回对应的值
前面提到的 后端返回 或 前端计算 产生的超过 安全范围的值，我们可以使用 BigInt 来处理，这是新增的原始值类型，它提供了一种方法来表示 大于 2^53 - 1 的整数。

这里的 BigInt 不能用来处理后端返回超过安全范围内的值（如 id），因为当我们需要再将这些值转为 BigInt 之前就已经发生了精度丢失，所以在进行转换是无意义的。此时最好的方式就是让后端处理数据，使接口以 字符串 的形式返回对应的值。